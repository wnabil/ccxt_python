# debug
import json
# -*- coding: utf-8 -*-

# PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
# https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

from ccxt.base.exchange import Exchange
from ccxt.abstract.pionex import ImplicitAPI
import hashlib
import collections
from ccxt.base.types import Int, Market, Num, Order, OrderSide, OrderType, Str, Strings, Ticker, Tickers, Trade, OrderBook, Balances, OrderRequest
from typing import List
from ccxt.base.errors import AuthenticationError
from ccxt.base.errors import ArgumentsRequired
from ccxt.base.errors import BadRequest
from ccxt.base.errors import InsufficientFunds
from ccxt.base.errors import InvalidAddress
from ccxt.base.errors import PermissionDenied
from ccxt.base.errors import BadSymbol
from ccxt.base.errors import DuplicateOrderId
from ccxt.base.errors import DDoSProtection
from ccxt.base.errors import OrderNotFound
from ccxt.base.decimal_to_precision import TICK_SIZE


class pionex(Exchange, ImplicitAPI):

    def describe(self):
        return self.deep_extend(super(pionex, self).describe(), {
            'id': 'pionex',
            'name': 'Pionex',
            'countries': ['EU'],
            'rateLimit': 100,
            'version': 'v1',
            'has': {
                'cancelAllOrders': True,
                'cancelOrder': True,
                'cancelOrders': False,
                'closeAllPositions': False,
                'closePosition': False,
                'createDepositAddress': False,
                'createMarketOrder': True,
                'createOrder': True,
                'createOrders': False, # TODO
                'createPostOnlyOrder': True,
                'createReduceOnlyOrder': False,
                'createStopLimitOrder': False,
                'createStopMarketOrder': False,
                'createStopOrder': False,
                'fetchAccounts': False,
                'fetchBalance': True,
                'fetchBorrowInterest': False,
                'fetchBorrowRateHistory': False,
                'fetchClosedOrders': False,
                'fetchCrossBorrowRate': False,
                'fetchCrossBorrowRates': False,
                'fetchDeposit': False,
                'fetchDepositAddress': False,
                'fetchDepositAddresses': False,
                'fetchDepositAddressesByNetwork': False,
                'fetchDeposits': False,
                'fetchDepositsWithdrawals': False,
                'fetchFundingHistory': False,
                'fetchFundingRate': False,
                'fetchFundingRateHistory': False,
                'fetchFundingRates': False,
                'fetchIndexOHLCV': False,
                'fetchIsolatedBorrowRate': False,
                'fetchIsolatedBorrowRates': False,
                'fetchLedger': False,
                'fetchLedgerEntry': False,
                'fetchLeverageTiers': False,
                'fetchMarketLeverageTiers': False,
                'fetchMarkets': True,
                'fetchMarkOHLCV': False,
                'fetchMyTrades': True,
                'fetchOHLCV': False,
                'fetchOpenInterest': False,
                'fetchOpenInterestHistory': False,
                'fetchOpenOrders': True,
                'fetchOrder': True,
                'fetchOrderBook': True,
                'fetchOrderBooks': True,
                'fetchOrders': True,
                'fetchOrderTrades': True,
                'fetchPosition': False,
                'fetchPositionHistory': False,
                'fetchPositionMode': False,
                'fetchPositions': False,
                'fetchPositionsForSymbol': False,
                'fetchPositionsHistory': False,
                'fetchPositionsRisk': False,
                'fetchPremiumIndexOHLCV': False,
                'fetchTicker': True,
                'fetchTickers': True,
                'fetchTrades': True,
                'fetchTradingLimits': False,
                'fetchTransactionFee': False,
                'fetchTransactionFees': False,
                'fetchTransactions': False,
                'fetchTransfers': False,
                'fetchWithdrawAddresses': False,
                'fetchWithdrawal': False,
                'fetchWithdrawals': False,
                'reduceMargin': False,
                'setLeverage': False,
                'setMargin': False,
                'setMarginMode': False,
                'setPositionMode': False,
                'signIn': False,
                'transfer': False,
                'withdraw': False,
            },
            'timeframes': {
                '1m': '1M',
                '5m': '5M',
                '15m': '15M',
                '30m': '30M',
                '1h': '60M',
                '4h': '4H',
                '8h': '8H',
                '12h': '12H',
                '1d': '1D',
            },
            'urls': {
                'api': {
                    'public': 'https://api.pionex.com',
                    'private': 'https://api.pionex.com',
                },
                'www': 'https://www.pionex.com/',
                'doc': 'https://pionex-doc.gitbook.io/apidocs',
                'fees': 'https://www.pionex.com/en/fees',
            },
            'api': {
                'public': {
                    'get': {
                        'common/symbols': 5,
                        'market/trades': 1,
                        'market/depth': 1,
                        'market/tickers': 1,
                        'market/bookTickers': 1,
                        'market/klines': 1,
                    },
                },
                'private': {
                    'get': {
                        'account/balances': 1,
                        'trade/order': 1,
                        'trade/orderByClientOrderId': 1,
                        'trade/openOrders': 5,
                        'trade/allOrders': 5,
                        'trade/fills': 5,
                        'trade/fillsByOrderId': 5,
                    },
                    'post': {
                        'trade/order': 1,
                        'trade/massOrder': 1,
                    },
                    'delete': {
                        'trade/order': 1,
                        'trade/allOrders': 1,
                    }
                },
            },
            'fees': {
                'trading': {
                    'tierBased': False,
                    'percentage': True,
                    'taker': self.parse_number('0.0005'),
                    'maker': self.parse_number('0.0005'),
                },
            },
            'precisionMode': TICK_SIZE,
            'exceptions': {
                'APIKEY_LOST': ArgumentsRequired,
                'SIGNATURE_LOST': ArgumentsRequired,
                'IP_NOT_WHITELISTED': InvalidAddress,
                'INVALIE_APIKEY': AuthenticationError,
                'INVALID_SIGNATURE': AuthenticationError,
                'APIKEY_EXPIRED': AuthenticationError,
                'INVALID_TIMESTAMP': BadRequest,
                'PERMISSION_DENIED': PermissionDenied,
                'TRADE_INVALID_SYMBOL': BadSymbol,
                'TRADE_PARAMETER_ERROR': BadRequest,
                'TRADE_NOT_ENOUGH_MONEY': InsufficientFunds,
                'TRADE_PRICE_FILTER_DENIED': BadRequest,
                'TRADE_SIZE_FILTER_DENIED': BadRequest,
                'TRADE_AMOUNT_FILTER_DENIED': BadRequest,
                'TRADE_REPEAT_CLIENT_ORDER_ID': DuplicateOrderId,
                'TRADE_OPEN_ORDER_EXCEED_LIMIT': DDoSProtection,
                'TRADE_OPERATION_DENIED': PermissionDenied,
                'TRADE_ORDER_NOT_FOUND': OrderNotFound,
            },
        })

    def fetch_markets(self, params={}) -> List[Market]:
        response = self.publicGetSymbols(params)
        #  { 
        #   "data": {
        #     "symbols":[
        #       {
        #         "symbol": "BTC_USDT",
        #         "type": "SPOT",
        #         "baseCurrency": "BTC",
        #         "quoteCurrency": "USDT",
        #         "basePrecision": 6,
        #         "quotePrecision": 2,
        #         "amountPrecision": 8,
        #         "minAmount": "10",
        #         "minTradeSize": "0.000001",
        #         "maxTradeSize": "1000",
        #         "minTradeDumping": "0.000001",
        #         "maxTradeDumping": "100",
        #         "enable": true,
        #         "buyCeiling": "1.1",
        #         "sellFloor": "0.9"
        #       }
        #     ]
        #   },
        #   "result": true,
        #   "timestamp": 1566676132311
        # }
        #
        #    {
        #        "success": True,
        #        "errorCode": "",
        #        "message": "",
        #        "result": [
        #            {
        #                "name": "ETH_BTC",
        #                "stock": "ETH",
        #                "money": "BTC",
        #                "precision": {
        #                    "money": "6",
        #                    "stock": "4",
        #                    "fee": "4"
        #                },
        #                "limits": {
        #                    "min_amount": "0.001",
        #                    "max_amount": "100000",
        #                    "step_size": "0.0001",
        #                    "min_price": "0.00001",
        #                    "max_price": "922327",
        #                    "tick_size": "0.00001",
        #                    "min_total": "0.0001"
        #                }
        #            },
        #            ...
        #        ]
        #    }
        #
        data = self.safe_value(response, 'data', {})
        markets = self.safe_value(data, 'symbols', [])
        return self.parse_markets(markets)

    def parse_market(self, market: dict) -> Market:
        baseId = self.safe_string(market, 'baseCurrency')
        quoteId = self.safe_string(market, 'quoteCurrency')
        type = self.safe_string_lower(market, 'type')
        spot = (type == 'spot')
        return {
            'id': baseId + '/' + quoteId,
            'symbol': self.safe_string(market, 'symbol'),
            'spot': spot,
            'type': type,
            'base': baseId,
            'quote': quoteId,
            'baseId': baseId,
            'quoteId': quoteId,
            'active': self.safe_string(market, 'enable'),
            'maker': 0.0005,
            'taker': 0.0005,
            'limits': {
                'amount': {
                    'min': self.safe_number(market, 'minTradeSize'),
                    'max': self.safe_number(market, 'maxTradeSize'),
                },
            },
            'precision': {
                'amount': self.safe_number(market, 'amountPrecision'),
                'base': self.safe_number(market, 'basePrecision'),
                'qoute': self.safe_number(market, 'quotePrecision'),
            },
            'info': market,
        }

    def fetch_trades(self, symbol: str, since: Int = None, limit: Int = None, params={}) -> List[Trade]:
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['symbol'],
            # 'limit': 100,     # default = 100, maximum = 500
        }
        if limit is not None:
            request['limit'] = min(limit, 500) # default = 100, maximum = 500
        response = None
        response = self.publicGetTrades(self.extend(request, params))
        data = self.safe_value(response, 'data', {})
        trades = self.safe_value(data, 'trades', [])
        return self.parse_trades(trades, market, since, limit)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        # { 
        # "data": {
        #     "trades": [
        #     {
        #         "symbol": "BTC_USDT",
        #         "tradeId": "600848671",
        #         "price": "7962.62",
        #         "size": "0.0122",
        #         "side": "BUY",
        #         "timestamp": 1566691672311
        #     },
        #     {
        #         "symbol": "BTC_USDT",
        #         "tradeId": "600848670",
        #         "price": "7960.12",
        #         "size": "0.0198",
        #         "side": "BUY",
        #         "timestamp": 1566691672311
        #     }
        #     ]
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        return self.safe_trade({
            'type': self.safe_string_lower(market, 'type'),
            'info': trade,
            'timestamp': self.safe_integer(trade, 'timestamp'),
            'id': self.safe_string(trade, 'tradeId'),
            'symbol': self.safe_string(trade, 'symbol'),
            'side': self.safe_string_lower(trade, 'side'),
            'price': self.safe_string(trade, 'price'),
            'amount': self.safe_string(trade, 'size'),
        }, market)

    def fetch_order_book(self, symbol: str, limit: Int = None, params={}) -> OrderBook:
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': market['symbol'],
            # 'limit': 20,     # default = 20, maximum = 1000
        }
        if limit is not None:
            request['limit'] = min(limit, 1000) # default = 20, maximum = 1000
        response = self.publicGetDepth(self.extend(request, params))
        # { 
        # "data": {
        #     "bids": [
        #         ["29658.37", "0.0123"],
        #         ["29658.35", "1.1234"],
        #         ["29657.99", "2.2345"],
        #         ["29657.56", "6.3456"],
        #         ["29656.13", "8.4567"]
        #     ],
        #     "asks": [
        #         ["29658.47", "0.0345"],
        #         ["29658.65", "1.0456"],
        #         ["29658.89", "3.5567"],
        #         ["29659.43", "5.2678"],
        #         ["29659.98", "1.9789"]
        #     ]，
        #     "updateTime": 1566676132311
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        orderBook = self.safe_dict(response, 'data', {})
        return self.parse_order_book(orderBook, market['symbol'], None, 'bids', 'asks')

    def fetch_ohlcv(self, symbol: str, timeframe='1m', since: Int = None, limit: Int = None, params={}) -> List[list]:
        self.load_markets()
        market = self.market(symbol)
        parsedTimeframe = self.safe_string(self.timeframes, timeframe)
        request: dict = {
            'symbol': market['symbol'],
        }
        if parsedTimeframe is not None:
            request['interval'] = parsedTimeframe
        else:
            request['interval'] = timeframe
        if limit is None:
            limit = 100  # max = 500
        else:
            limit = min(500, limit)
        # {
        # "result": true,
        # "data": {
        #     "klines": [
        #     {
        #         "time": 1691649240000,
        #         "open": "1851.27",
        #         "close": "1851.32",
        #         "high": "1851.32",
        #         "low": "1851.27",
        #         "volume": "0.542"
        #     }
        #     ]
        # },
        # "timestamp": 1691649271544
        # }
        response = self.publicGetMarketKlines(self.extend(request, params))
        data = self.safe_dict(response, 'data', {})
        klines = self.safe_value(data, 'klines', [])
        return self.parse_ohlcvs(klines, market, timeframe, since, limit)

    def parse_ohlcv(self, ohlcv, market: Market = None) -> list:
        return [
            self.safe_integer(ohlcv, 'time'),  # timestamp
            self.safe_number(ohlcv, 'open'),  # open
            self.safe_number(ohlcv, 'high'),  # high
            self.safe_number(ohlcv, 'low'),  # low
            self.safe_number(ohlcv, 'close'),  # close
            self.safe_number(ohlcv, 'volume'),  # volume
        ]

    def fetch_tickers(self, symbols: Strings = None, params={}) -> Tickers:
        self.load_markets()
        request: dict = {
            'type': 'SPOT'
        }
        response = self.publicGetTickers(self.extend(request, params))
        response2 = self.publicGetBookTickers(self.extend(request, params))
        # { 
        # "data": {
        #     "tickers": [
        #     {
        #         "symbol": "BTC_USDT",
        #         "time": 1545291675000,
        #         "open": "7962.62",
        #         "close": "7952.32",
        #         "high": "7971.61",
        #         "low": "7950.29",
        #         "volume": "1.537",
        #         "amount": "12032.56",
        #         "count": 271585
        #     },
        #     {
        #         "symbol": "ETH_USDT",
        #         "time": 1545291675000,
        #         "open": "1963.62",
        #         "close": "1852.22",
        #         "high": "1971.11",
        #         "low": "1850.23",
        #         "volume": "100.532",
        #         "amount": "112012.51",
        #         "count": 432211
        #     }  
        #     ]
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }

        # { 
        # "data": {
        #     "tickers": [
        #     ]
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        data = self.safe_dict(response, 'data')
        data2 = self.safe_dict(response2, 'data')
        tickers = self.safe_list(data, 'tickers')
        tickers2 = self.safe_list(data2, 'tickers')
        tickersFinal = []
        for ticker in tickers:
            for ticker2 in tickers2:
                if ticker2['symbol'] == ticker['symbol']:
                    tickersFinal.append(ticker | ticker2)
        return self.parse_tickers(tickers + tickers2, symbols)

    def parse_ticker(self, ticker: dict, market: Market = None) -> Ticker:
        timestamp = self.safe_number(ticker, 'time')
        return self.safe_ticker({
            'symbol': self.safe_string(ticker, 'symbol'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'high': self.safe_number(ticker, 'high'),
            'low': self.safe_number(ticker, 'low'),
            'open': self.safe_number(ticker, 'open'),
            'close': self.safe_number(ticker, 'close'),
            'baseVolume': self.safe_number(ticker, 'volume'),
            'info': ticker,
            'bid': self.safe_number(ticker, 'bidPrice'),
            'bidVolume': self.safe_number(ticker, 'bidSize'),
            'ask': self.safe_number(ticker, 'askPrice'),
            'askVolume': self.safe_number(ticker, 'askSize'),
        }, market)

    def fetch_balance(self, params={}):
        response = self.privateGetAccountBalances(params)
        # { 
        # "data": {
        #     "balances": [
        #     {
        #         "coin": "BTC",
        #         "free": "0.9000000",
        #         "frozen": "0.00000000"
        #     },
        #     {
        #         "coin": "USDT",
        #         "free": "100.00000000",
        #         "frozen": "900.00000000"
        #     }
        #     ]
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        return self.parse_balance(response)

    def parse_balance(self, response) -> Balances:
        data = self.safe_dict(response, 'data')
        balances = self.safe_list(data, 'balances')
        timestamp = self.safe_string(response, 'timestamp')
        result: dict = {
            'info': balances,
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp)
        }
        for i in range(0, len(balances)):
            balance = balances[i]
            currencyId = self.safe_string(balance, 'coin')
            code = self.safe_currency_code(currencyId)
            account = self.account()
            account['free'] = self.safe_number(balance, 'free')
            frozen = self.safe_number(balance, 'frozen')
            account['total'] = account['free'] + frozen
            result[code] = account
        return self.safe_balance(result)

    def fetch_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': symbol,
        }
        if limit is None:
            limit = 50  # max = 200
        else:
            limit = min(200, limit)
        # { 
        # "data": {
        #     "orders":[
        #     {
        #         "orderId": 1234567890,
        #         "symbol": "BTC_USDT",
        #         "type": "LIMIT",
        #         "side": "SELL",
        #         "price": "30000.00",
        #         "size": "0.1000",
        #         "filledSize": "0.0500",
        #         "filledAmount": "1500.00",
        #         "fee":  "0.15",
        #         "feeCoin":  "USDT",
        #         "status": "OPEN",
        #         "IOC": false,
        #         "clientOrderId":  "9e3d93d6-e9a4-465a-a39c-2e48568fe194",
        #         "source": "API",
        #         "createTime": 1566676132311,
        #         "updateTime": 1566676132311
        #     }
        #     ]
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        response = self.privateGetAllOrders(self.extend(request, params))
        data = self.safe_dict(response, 'data', {})
        orders = self.safe_value(data, 'orders', [])
        return self.parse_orders(orders, market, since, limit)

    def fetch_open_orders(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}) -> List[Order]:
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': symbol,
        }
        if limit is None:
            limit = 50  # max = 200
        else:
            limit = min(200, limit)
        # { 
        # "data": {
        #     "orders":[
        #     {
        #         "orderId": 1234567890,
        #         "symbol": "BTC_USDT",
        #         "type": "LIMIT",
        #         "side": "SELL",
        #         "price": "30000.00",
        #         "size": "0.1000",
        #         "filledSize": "0.0500",
        #         "filledAmount": "1500.00",
        #         "fee":  "0.15",
        #         "feeCoin":  "USDT",
        #         "status": "OPEN",
        #         "IOC": false,
        #         "clientOrderId":  "9e3d93d6-e9a4-465a-a39c-2e48568fe194",
        #         "source": "API",
        #         "createTime": 1566676132311,
        #         "updateTime": 1566676132311
        #     }
        #     ]
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        response = self.privateGetOpenOrders(self.extend(request, params))
        data = self.safe_dict(response, 'data', {})
        orders = self.safe_value(data, 'orders', [])
        return self.parse_orders(orders, market, since, limit)

    def fetch_order(self, id: str, symbol: Str = None, params={}):
        self.load_markets()
        clientOrderId = self.safe_value_2(params, 'client_order_id', 'clientOrderId')
        request: dict = {
        }
        if clientOrderId is not None:
            request['clientOrderId'] = clientOrderId
            params = self.omit(params, ['client_order_id', 'clientOrderId'])
            response = self.privateGetOrderByClientOrderId(self.extend(request, params))
        else:
            request['orderId'] = id
            response = self.privateGetOrder(self.extend(request, params))
        # { 
        # "data": {
        #     "orderId": 1234567890,
        #     "symbol": "BTC_USDT",
        #     "type": "LIMIT",
        #     "side": "SELL",
        #     "price": "30000.00",
        #     "size": "0.1000",
        #     "filledSize": "0.0500",
        #     "filledAmount": "1500.00",
        #     "fee":  "0.15",
        #     "feeCoin":  "USDT",
        #     "status": "OPEN",
        #     "IOC":  false,
        #     "clientOrderId":  "9e3d93d6-e9a4-465a-a39c-2e48568fe194",
        #     "source": "API",
        #     "createTime": 1566676132311,
        #     "updateTime": 1566676132311
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        data = self.safe_dict(response, 'data')
        return self.parse_order(data, None)

    def parse_order(self, order: dict, market: Market = None) -> Order:
        timestamp = self.safe_number(order, 'createTime')
        size = self.safe_number(order, 'size')
        filledSize = self.safe_number(order, 'filledSize')
        side = self.safe_string_lower(order, 'side')
        remaining = size - filledSize
        average = 0
        if filledSize: 
            average = self.safe_number(order, 'filledAmount') / filledSize
        if side == 'buy' :
            remaining = filledSize - size
        return self.safe_order({
            'id': self.safe_string(order, 'orderId'),
            'clientOrderId': self.safe_string(order, 'clientOrderId'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'lastTradeTimestamp': self.safe_number(order, 'updateTime'),
            'status': self.safe_string_lower(order, 'status'),
            'symbol': self.safe_string(order, 'symbol'),
            'type': self.safe_string_lower(order, 'type'),
            'timeInForce': None,
            'postOnly': self.safe_bool(order, 'IOC'),
            'side': side,
            'price': self.safe_number(order, 'price'),
            'stopPrice': None,
            'triggerPrice': self.safe_number(order, 'price'),
            'amount': size,
            'filled': filledSize,
            'remaining': remaining,
            'cost':  self.safe_number(order, 'fee'),
            'trades': None,
            'average': average,
            'fee': {
                'currency': self.safe_string(order, 'feeCoin'),
                'cost': self.safe_string(order, 'fee'),
            },
            'info': order,
        }, market)

    def fetch_my_trades(self, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        self.load_markets()
        request: dict = {
            'symbol': symbol,
        }
        market = None
        if symbol is not None:
            market = self.market(symbol)
        response = self.privateGetFills(params)
        # {
        # "data": {
        #     "fills":[
        #     {
        #         "id": 9876543210,
        #         "orderId": 123456789,
        #         "symbol": "BTC_USDT",
        #         "side": "SELL",
        #         "role":  "TAKER",
        #         "price": "30000.00",
        #         "size": "0.1000",
        #         "fee":  "0.15",
        #         "feeCoin":  "USDT",
        #         "timestamp": 1566676132311
        #     },
        #     {
        #         "id": 9876543200,
        #         "orderId": 123456789,
        #         "symbol": "BTC_USDT",
        #         "side": "SELL",
        #         "role":  "TAKER",
        #         "price": "29000.00",
        #         "size": "0.1200",
        #         "fee":  "0.145",
        #         "feeCoin":  "USDT",
        #         "timestamp": 1566676132310
        #     }
        #     ]
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        response = self.privateGetFills(self.extend(request, params))
        data = self.safe_dict(response, 'data', {})
        fills = self.safe_value(data, 'fills', [])
        return self.parse_trades(fills, market, since, limit)

    def parse_trade(self, trade: dict, market: Market = None) -> Trade:
        timestamp = self.safe_string(trade, 'timestamp')
        fee = self.safe_number(trade, 'fee')
        return self.safe_trade({
            'info': trade,
            'id': self.safe_string(trade, 'id'),
            'symbol': self.safe_string(trade, 'symbol'),
            'timestamp': timestamp,
            'datetime': self.iso8601(timestamp),
            'order': self.safe_string(trade, 'orderId'),
            'type': self.safe_string_lower(market, 'type'),
            'side': self.safe_string_lower(trade, 'side'),
            'takerOrMaker': self.safe_string_lower(trade, 'role'),
            'price': self.safe_string(trade, 'price'),
            'amount': self.safe_string(trade, 'size'),
            'cost': fee,
            'fee': {
                'cost': fee,
                'currency': self.safe_string(trade, 'feeCoin')
            },
        })

    def fetch_order_trades(self, id: str, symbol: Str = None, since: Int = None, limit: Int = None, params={}):
        self.load_markets()
        market = None
        if symbol is not None:
            market = self.market(symbol)
        request: dict = {
            'orderId': id,
        }
        # {
        # "data": {
        #     "fills":[
        #     {
        #         "id": 9876543210,
        #         "orderId": 123456789,
        #         "symbol": "BTC_USDT",
        #         "side": "SELL",
        #         "role":  "TAKER",
        #         "price": "30000.00",
        #         "size": "0.1000",
        #         "fee":  "0.15",
        #         "feeCoin":  "USDT",
        #         "timestamp": 1566676132311
        #     },
        #     {
        #         "id": 9876543200,
        #         "orderId": 123456789,
        #         "symbol": "BTC_USDT",
        #         "side": "SELL",
        #         "role":  "TAKER",
        #         "price": "29000.00",
        #         "size": "0.1200",
        #         "fee":  "0.145",
        #         "feeCoin":  "USDT",
        #         "timestamp": 1566676132310
        #     }
        #     ]
        # },
        # "result": true,
        # "timestamp": 1566691672311
        # }
        response = self.privateGetFillsByOrderId(self.extend(request, params))
        data = self.safe_dict(response, 'data', {})
        fills = self.safe_value(data, 'fills', [])
        return self.parse_trades(fills, market, since, limit)

    def cancel_order(self, id: str, symbol: Str = None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': symbol,
            'orderId': id
        }
        response = self.privateDeleteCancelOrder(self.extend(request, params))
        # { 
        # "result": true,
        # "timestamp": 1566691672311
        # }
        order = self.safe_order({'id': id, 'symbol': market['symbol'], 'info': {}}, market)
        return order

    def cancel_all_orders(self, symbol: Str = None, params={}):
        self.load_markets()
        market = self.market(symbol)
        request: dict = {
            'symbol': symbol,
        }
        response = self.privateDeleteAllOrders(self.extend(request, params))
        # { 
        # "result": true,
        # "timestamp": 1566691672311
        # }
        order = self.safe_order({'symbol': market['symbol'], 'info': {}}, market)
        return [order]

    def create_order(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        self.load_markets()
        market = self.market(symbol)
        # print(json.dumps(market, indent=2))
        # return
        clientOrderId = self.safe_string_2(params, 'client_order_id', 'clientOrderId', self.uuid())
        request: dict = {
            'symbol': symbol,
            'side': side.upper(),
            'type': type.upper(),
            'amount': self.amount_to_precision(symbol, amount),
            'size': self.amount_to_precision(symbol, amount),
            'IOC': self.safe_bool(params, 'postOnly', False),
            'clientOrderId': clientOrderId
        }
        if price:
            request['price'] = price
        response = self.privatePostNewOrder(self.extend(request, params))
        data = self.safe_dict(response, 'data', {})
        request['orderId'] = data['orderId']
        return self.parse_order(request, market)

    def create_orders(self, orders: List[OrderRequest], params={}):
        self.load_markets()
        ordersRequests = []
        for i in range(0, len(orders)):
            rawOrder = orders[i]
            symbol = self.safe_string(rawOrder, 'symbol')
            type = self.safe_string(rawOrder, 'type')
            side = self.safe_string_upper(rawOrder, 'side')
            amount = self.safe_number(rawOrder, 'amount')
            price = self.safe_string(rawOrder, 'price')
            orderParams = self.safe_dict(rawOrder, 'params', {})
            orderRequest = self.create_order_request(symbol, type, side, amount, price, orderParams)
            ordersRequests.append(orderRequest)
        firstOrder = ordersRequests[0]
        firstSymbol = self.safe_string(firstOrder, 'symbol')
        market = self.market(firstSymbol)
        request: dict = {
            'symbol': firstSymbol,
            'orders': ordersRequests,
        }
        response = self.privatePostNewMassOrder(self.extend(request, params))
        data = self.safe_dict(response, 'data', {})
        orderIds = self.safe_list(data, 'orderIds', [])
        responseOrders = []
        for i in range(0, len(orderIds)):
            responseOrder = self.safe_dict(orderIds, i, {})
            orderRequests = self.safe_dict(ordersRequests, i, {})
            orderRequests['orderId'] = responseOrder['orderId']
            responseOrders.append(orderRequests)
        return self.parse_orders(responseOrders)

    def create_order_request(self, symbol: str, type: OrderType, side: OrderSide, amount: float, price: Num = None, params={}):
        market = self.market(symbol)
        clientOrderId = self.safe_string_2(params, 'client_order_id', 'clientOrderId', self.uuid())
        params = self.omit(params, ['client_order_id', 'clientOrderId'])
        request: dict = {
            'clientOrderId': clientOrderId,
            'side': side,
            'symbol': symbol,
            'type': 'LIMIT',  # Only support LIMIT.
            'size': self.amount_to_precision(symbol, amount),
            'price': price
        }
        return self.extend(request, params)


    def sign(self, path, api='public', method='GET', params={}, headers=None, body=None):
        endpointPath = '/api/v1/' + self.implode_params(path, params)
        url = self.urls['api'][api] + endpointPath
        params = self.omit(params, self.extract_params(path))
        if params and method == 'GET' and api != 'private':
            if params:
                url += '?' + self.urlencode(params)
        if api == 'private':
            if bool(params) and (method == 'POST' or method == 'DELETE'):
                body = self.json(params)
            params['timestamp'] = self.milliseconds()
            url += '?' + self.urlencode(params)
            sortedParams = collections.OrderedDict(sorted(params.items()))
            structedPath = method + endpointPath + '?' + self.urlencode(sortedParams)
            if body:
                structedPath = structedPath + body
            signature = self.hmac(self.encode(structedPath), self.encode(self.secret))
            headers = {
                'Content-Type': 'application/json',
                'PIONEX-KEY': self.apiKey,
                'PIONEX-SIGNATURE': signature,
            }
        return {'url': url, 'method': method, 'body': body, 'headers': headers}

    def handle_errors(self, code: int, reason: str, url: str, method: str, headers: dict, body: str, response, requestHeaders, requestBody):
        if response is None:
            return None
        if code == 400:
            error = self.safe_value(response, 'message')
            errorCode = self.safe_string(response, 'code')
            feedback = self.id + ' ' + self.json(response)
            self.throw_exactly_matched_exception(self.exceptions, errorCode, feedback)
            # fallback to default error handler
        return None
